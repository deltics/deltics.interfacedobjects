
{$i deltics.interfacedobjects.inc}

  unit Deltics.InterfacedObjects.InterfacedObject;


interface

  uses
    Deltics.Multicast,
    Deltics.InterfacedObjects.Interfaces.IInterfacedObject,
    Deltics.InterfacedObjects.ObjectLifecycle;


  type
    // @TInterfacedObjectBase
    //
    //  Provides a base class for objects that implement interfaces but with
    //   explicit lifetime management (must be Free'd and are NOT reference
    //   counted).
    //
    //  Reference counting is still taking place (the calls are generated by
    //   the compiler and are unavoidable) but the implementation does not
    //   track the reference count and does not free itself when there are
    //   no references left.
    //
    TInterfacedObject = class(TObject, IUnknown,
                                       IInterfacedObject,
                                       IOn_Destroy)
      private
        fIsBeingDestroyed: Boolean;
        fOn_Destroy: IOn_Destroy;
      protected
        property IsBeingDestroyed: Boolean read fIsBeingDestroyed;
      public
        procedure BeforeDestruction; override;

      // IUnknown
      protected
        function QueryInterface(const IID: TGUID; out Obj): HResult; stdcall;
        function _AddRef: Integer; virtual; stdcall;
        function _Release: Integer; virtual; stdcall;

      // IInterfacedObject
      protected
        function get_IsReferenceCounted: Boolean; virtual;
        function get_Lifecycle: TObjectLifecycle; virtual;
        function get_Object: TObject;
        function get_ReferenceCount: Integer; virtual;
        property Lifecycle: TObjectLifecycle read get_Lifecycle;
        property ReferenceCount: Integer read get_ReferenceCount;

      // IOn_Destroy
      protected
        function get_On_Destroy: IOn_Destroy;
      public
        property On_Destroy: IOn_Destroy read get_On_Destroy implements IOn_Destroy;
    end;



implementation

{ TInterfacedObjectBase -------------------------------------------------------------------------- }

  { - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - }
  function TInterfacedObject.QueryInterface(const IID: TGUID;
                                                out   Obj): HResult;
  begin
    if GetInterface(IID, Obj) then
      Result := 0
    else
      Result := E_NOINTERFACE;
  end;


  { - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - }
  function TInterfacedObject._AddRef: Integer;
  begin
    result := 1; { NO-OP }
  end;


  { - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - }
  function TInterfacedObject._Release: Integer;
  begin
    result := 1; { NO-OP }
  end;


  { - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - }
  procedure TInterfacedObject.BeforeDestruction;
  begin
    fIsBeingDestroyed := TRUE;

    inherited;
  end;


  { - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - }
  function TInterfacedObject.get_IsReferenceCounted: Boolean;
  begin
    result := FALSE;
  end;


  { - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - }
  function TInterfacedObject.get_Lifecycle: TObjectLifecycle;
  begin
    result := olExplicit;
  end;


  { - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - }
  function TInterfacedObject.get_Object: TObject;
  begin
    result := self;
  end;


  { - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - }
  function TInterfacedObject.get_On_Destroy: IOn_Destroy;
  // Create the multi-cast event on demand, since we cannot
  //  guarantee any particular constructor call order and there
  //  may be dependencies created during construction (e.g. if
  //  multi-cast event handlers are added before/after any call
  //  to a particular inherited constructor etc etc)
  begin
    if NOT fIsBeingDestroyed and NOT Assigned(fOn_Destroy) then
      fOn_Destroy := TOnDestroy.Create(self);

    result := fOn_Destroy;
  end;


  { - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - }
  function TInterfacedObject.get_ReferenceCount: Integer;
  begin
    result := 1;
  end;




end.
